#' @title t-test Values
#' @description Calculate t-test and Return Key Values
#' @details Calculate t-test and return the key values.
#'
#' @param data The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param alternative The type of t-test analysis; default: `"two.sided"`
#' @param paired `logical` indicating if the data is the result of a paired
#'   sample; default: `FALSE`
#' @param conf.level The confidence level; default: `0.99`
#' @param na.rm `logical` indicating if `NA` values are removed; default: `TRUE`
#'
#' @return t.value The t-test value
#' @return df The degrees of freedom
#' @return p.value The p-value
#'
#' @export
#'
#' @examples
#'   values <- list(a=1:3, b=1:5, c=1:10, d=1:20)
#'   t.test.combinations(values)
#'
#'   values <- list(a=1:3, b=1:5, c=1:10, d=1:20)
#'   t.test.combinations(values)
#'
#'
#' @author Emilio Xavier Esposito \email{emilio@@exeResearch.com}
#'   ([https://github.com/emilioxavier](https://github.com/emilioxavier))
#'
values.t.test <- function(x, y, alternative="two.sided", paired=FALSE, conf.level=0.99, na.rm=TRUE) {

  t.values <- t.test(x=x, y=y,
                     alternative=alternative,
                     paired=paired,
                     conf.level=conf.level,
                     na.rm=na.rm)

  values <- prettyNum(c(as.numeric(t.values$statistic),  ## t value
                        as.numeric(t.values$parameter),  ## degrees of freedom
                        t.values$p.value))               ## p-value

  return(values)

}


#' @title t-test Combinations
#' @description Calculate all t-test Combinations
#' @details Calculate all t-test combinations within a list of values.
#'
#' @param data The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param alternative The type of t-test analysis; default: `"two.sided"`
#' @param paired `logical` indicating if the data is the result of a paired
#'   sample; default: `FALSE`
#' @param conf.level The confidence level; default: `0.99`
#' @param na.rm `logical` indicating if `NA` values are removed; default: `TRUE`
#'
#' @return A `data.frame` with the `t-value`, degrees of freedom (`df`), and `p-value`.
#'
#' @importFrom utils combn
#'
#' @export
#'
#' @examples
#'   values <- list(a=1:3, b=1:5, c=1:10, d=1:20)
#'   combinations.t.test(values)
#'
#' @author Emilio Xavier Esposito \email{emilio@@exeResearch.com}
#'   ([https://github.com/emilioxavier](https://github.com/emilioxavier))
#'
combinations.t.test <- function(data,
                                alternative="two.sided",
                                paired=FALSE,
                                conf.level=0.99,
                                na.rm=TRUE) {

  ##_ get group names -----
  names.groups <- names(data)
  ##__ if group names not provided, create -----
  if ( is.null(names.groups) == TRUE ) {
    num.groups <- length(data)
    max.group.nchar <- nchar(num.groups)
    group.idc <- seq_len(num.groups)
    num.groups.pretty <- formatC(group.idc, format="d", width=max.group.nchar, flag="0")
    names.groups <- paste0("group", num.groups.pretty)
    message("No group names provided, thus, group names created")
  }

  ##_ construct output data.frame -----
  num.groups <- length(names.groups)
  pairs.data <- combn(1:num.groups, 2)
  num.pairs <- ncol(pairs.data)
  num.df.results.rows <- num.groups * 3

  df.results <- as.data.frame(matrix(data=NA, nrow=num.df.results.rows, ncol=num.groups))
  df.row.names.t      <- paste0(names.groups, "_t")
  df.row.names.df     <- paste0(names.groups, "_df")
  df.row.names.pvalue <- paste0(names.groups, "_pvalue")

  ##__ row indices for row names -----
  t.rows.idc      <- seq(from=1, to=num.df.results.rows, by=3)
  df.rows.idc     <- seq(from=2, to=num.df.results.rows, by=3)
  pvalue.rows.idc <- seq(from=3, to=num.df.results.rows, by=3)

  ##__ update row and column names -----
  rownames(df.results)[t.rows.idc] <- df.row.names.t
  rownames(df.results)[df.rows.idc] <- df.row.names.df
  rownames(df.results)[pvalue.rows.idc] <- df.row.names.pvalue
  colnames(df.results) <- names.groups

  ##_ get the group pairs -----
  pairs.row1 <- pairs.data[1, ]
  pairs.row2 <- pairs.data[2, ]

  ##_ evaluate all group pairs -----
  for (curr.pair in seq_len(num.pairs)) {

    ##__ get the values -----
    x.values <- unlist(data[pairs.row1[curr.pair]])
    y.values <- unlist(data[pairs.row2[curr.pair]])

    ##__ determine rows and column for results -----
    results.row.last <- pairs.row1[curr.pair] * 3
    results.row.first <- results.row.last - 2
    results.rows <- results.row.first:results.row.last
    results.col <- pairs.row2[curr.pair]

    ##__ calculate the t-tests -----
    df.results[results.rows, results.col] <- values.t.test(x=x.values,
                                                           y=y.values,
                                                           alternative=alternative,
                                                           paired=paired,
                                                           conf.level=conf.level,
                                                           na.rm=na.rm)
  }

  ##_ return the results -----
  return(df.results)

}

