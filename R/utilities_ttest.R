#' @title t-test & Cohen's d Values
#' @description Calculate t-test, Cohen's d, and Return Key Values
#' @details Calculate t-test, Cohen's d, and return the key values.
#'
#' @param x The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param y The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param alternative The type of t-test analysis; default: `"two.sided"`
#' @param paired `logical` indicating if the data is the result of a paired
#'   sample; default: `FALSE`
#' @param conf.level The confidence level; default: `0.99`
#' @param na.rm `logical` indicating if `NA` values are removed; default: `TRUE`
#' @param CER `numerical` value indicating the control event rate (CER); default: `0.20`
#'
#' @return t.value The t-test value
#' @return df The degrees of freedom
#' @return p.value The p-value
#' @return Cohens.d The Cohen's d value
#' @return Cohens.U3 The Cohen's U3 value
#'
#' @importFrom stats t.test
#' @importFrom effectsize cohens_d
#'
#' @export
#'
#' @author Emilio Xavier Esposito \email{emilio@@exeResearch.com}
#'   ([https://github.com/emilioxavier](https://github.com/emilioxavier))
#'
values.t.test <- function(x, y, alternative="two.sided", paired=FALSE, conf.level=0.99, na.rm=TRUE, CER=0.20) {

  t.values <- t.test(x=x, y=y,
                     alternative=alternative,
                     paired=paired,
                     conf.level=conf.level,
                     na.rm=na.rm)

  Cohens.d.values <- effectsize::cohens_d(x=x,
                                          y=y,
                                          alternative=alternative,
                                          ci=conf.level)

  Cohens.U3.values <- effectsize::cohens_u3(x=x,
                                          y=y,
                                          alternative=alternative,
                                          ci=conf.level)

  ProbSuperiority.values <- effectsize::p_superiority(x=x,
                                                      y=y,
                                                      alternative=alternative,
                                                      ci=conf.level)

  ProbOverlap.values <- effectsize::p_overlap(x=x,
                                              y=y,
                                              alternative=alternative,
                                              ci=conf.level)

  ## Number Needed to Treat
  ##_ based on:
  ## https://rpsychologist.com/cohend/
  # CER <- 0.2
  # d <- 0.2
  # 1 / (pnorm(d + qnorm(CER))-CER)
  NumberNeededToTreat <- 1 / (pnorm(Cohens.d.values$Cohens_d + qnorm(CER))-CER)

  ## collect values ----
  values <- prettyNum(c(as.numeric(t.values$statistic),  ## t value
                        as.numeric(t.values$parameter),  ## degrees of freedom
                        t.values$p.value,                ## p-value
                        Cohens.d.values$Cohens_d,       ## Cohen's d
                        Cohens.U3.values$Cohens_U3,           ## Cohen's U3
                        ProbSuperiority.values$p_superiority, ## probability of superiority
                        ProbOverlap.values$Overlap,           ## probability of overlap
                        NumberNeededToTreat                   ## number needed to treat
                        )
                      ) |>
    setNames(nm=c("tValue", "DoF", "pValue", "Cohens_d", "Cohens_U3", "ProbSuperiority", "ProbOverlap", "NNT"))

  return(values)

}


#' @title t-test Combinations
#' @description Calculate all t-test Combinations
#' @details Calculate all t-test combinations within a list of values.
#'
#' @param data The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param alternative The type of t-test analysis; default: `"two.sided"`
#' @param paired `logical` indicating if the data is the result of a paired
#'   sample; default: `FALSE`
#' @param conf.level The confidence level; default: `0.99`
#' @param na.rm `logical` indicating if `NA` values are removed; default: `TRUE`
#' @param CER `numerical` value indicating the control event rate (CER); default: `0.20`
#'
#' @return A `data.frame` or `tibble` with the `t-value`, degrees of freedom
#'   (`df`), and `p-value`.
#'
#' @importFrom utils combn
#' @importFrom dplyr select
#' @importFrom tidyselect where
#' @importFrom tibble as_tibble is_tibble rownames_to_column
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   values.ls <- list(a=1:3, b=1:5, c=1:10, d=1:20, e=letters[1:20])
#'   values.tb <- tibble::tibble(a=1:10, b=11:20, c=21:30, d=31:40, e=letters[1:10])
#'   combinations.t.test(values.ls)
#'   combinations.t.test(values.tb)
#' }
#'
#' @author Emilio Xavier Esposito \email{emilio@@exeResearch.com}
#'   ([https://github.com/emilioxavier](https://github.com/emilioxavier))
#'
combinations.t.test <- function(data,
                                alternative="two.sided",
                                paired=FALSE,
                                conf.level=0.99,
                                na.rm=TRUE,
                                CER=0.20) {

  ## is data.frame or tibble or list ----
  tb.tf <- is_tibble(data)
  df.tf <- is.data.frame(data)

  ## convert to list ----
  if ( tb.tf | df.tf ) {
    # data <- select(data, -where(is.character))
    data <- as.list(data)
  }

  ## remove character vectors ----
  data <- data[!sapply(X=data, FUN=is.character)]

  ## get group names ----
  names.groups <- names(data)
  ##_ if group names not provided, create ----
  if ( is.null(names.groups) == TRUE ) {
    num.groups <- length(data)
    max.group.nchar <- nchar(num.groups)
    group.idc <- seq_len(num.groups)
    num.groups.pretty <- formatC(group.idc, format="d", width=max.group.nchar, flag="0")
    names.groups <- paste0("group", num.groups.pretty)
    message("No group names provided, thus, group names created")
  }

  ## construct output data.frame ----
  num.groups <- length(names.groups)
  pairs.data <- combn(1:num.groups, 2)
  num.pairs <- ncol(pairs.data)
  num.df.results.rows <- num.groups * 8

  df.results <- as.data.frame(matrix(data=NA, nrow=num.df.results.rows, ncol=num.groups))
  df.row.names.t      <- paste0(names.groups, "_t")
  df.row.names.df     <- paste0(names.groups, "_df")
  df.row.names.pvalue <- paste0(names.groups, "_pValue")
  df.row.names.Cohensd <- paste0(names.groups, "_Cohensd")
  df.row.names.CohensU3 <- paste0(names.groups, "_CohensU3")
  df.row.names.ProbSupr <- paste0(names.groups, "_ProbSuperiority")
  df.row.names.ProbOvrlp <- paste0(names.groups, "_ProbOverlap")
  df.row.names.NNT <- paste0(names.groups, "_NNT")

  ##_ row indices for row names ----
  t.rows.idc       <- seq(from=1, to=num.df.results.rows, by=8)
  df.rows.idc      <- seq(from=2, to=num.df.results.rows, by=8)
  pvalue.rows.idc  <- seq(from=3, to=num.df.results.rows, by=8)
  Cohensd.rows.idc <- seq(from=4, to=num.df.results.rows, by=8)
  CohensU3.rows.idc <- seq(from=5, to=num.df.results.rows, by=8)
  ProbSupr.rows.idc <- seq(from=6, to=num.df.results.rows, by=8)
  ProbOvrlp.rows.idc <- seq(from=7, to=num.df.results.rows, by=8)
  NNT.rows.idc <- seq(from=8, to=num.df.results.rows, by=8)

  ##_ update row and column names ----
  rownames(df.results)[t.rows.idc] <- df.row.names.t
  rownames(df.results)[df.rows.idc] <- df.row.names.df
  rownames(df.results)[pvalue.rows.idc] <- df.row.names.pvalue
  rownames(df.results)[Cohensd.rows.idc] <- df.row.names.Cohensd
  rownames(df.results)[CohensU3.rows.idc] <- df.row.names.CohensU3
  rownames(df.results)[ProbSupr.rows.idc] <- df.row.names.ProbSupr
  rownames(df.results)[ProbOvrlp.rows.idc] <- df.row.names.ProbOvrlp
  rownames(df.results)[NNT.rows.idc] <- df.row.names.NNT
  colnames(df.results) <- names.groups

  ## get the group pairs ----
  pairs.row1 <- pairs.data[1, ]
  pairs.row2 <- pairs.data[2, ]

  ## evaluate all group pairs ----
  for (curr.pair in seq_len(num.pairs)) {

    # message("current pair idx: ", curr.pair)

    ##_ get the values ----
    x.values <- unlist(data[pairs.row1[curr.pair]])
    y.values <- unlist(data[pairs.row2[curr.pair]])

    ##_ determine rows and column for results ----
    results.row.last <- pairs.row1[curr.pair] * 8
    results.row.first <- results.row.last - 7
    results.rows <- results.row.first:results.row.last
    results.col <- pairs.row2[curr.pair]
    # message("results row: ", results.rows, " results column: ", results.col, "\n")

    ##_ calculate the t-tests ----
    df.results[results.rows, results.col] <- values.t.test(x=x.values,
                                                           y=y.values,
                                                           alternative=alternative,
                                                           paired=paired,
                                                           conf.level=conf.level,
                                                           na.rm=na.rm,
                                                           CER=CER)
  }

  ## remove column and rows of NAs ----
  df.results <- df.results[-c((num.df.results.rows-7):num.df.results.rows), -1]

  ## convert results to tibble if started as tibble ----
  if ( tb.tf ) {
    df.results <- rownames_to_column(df.results, var="t.test.param")
    df.results <- as_tibble(df.results)
  }

  ## return the results ----
  return(df.results)

}


