#' @title t-test Values
#' @description Calculate t-test and Return Key Values
#' @details Calculate t-test and return the key values.
#'
#' @param x The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param y The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param alternative The type of t-test analysis; default: `"two.sided"`
#' @param paired `logical` indicating if the data is the result of a paired
#'   sample; default: `FALSE`
#' @param conf.level The confidence level; default: `0.99`
#' @param na.rm `logical` indicating if `NA` values are removed; default: `TRUE`
#'
#' @return t.value The t-test value
#' @return df The degrees of freedom
#' @return p.value The p-value
#'
#' @importFrom stats t.test
#'
#' @export
#'
#' @author Emilio Xavier Esposito \email{emilio@@exeResearch.com}
#'   ([https://github.com/emilioxavier](https://github.com/emilioxavier))
#'
values.t.test <- function(x, y, alternative="two.sided", paired=FALSE, conf.level=0.99, na.rm=TRUE) {

  t.values <- t.test(x=x, y=y,
                     alternative=alternative,
                     paired=paired,
                     conf.level=conf.level,
                     na.rm=na.rm)

  values <- prettyNum(c(as.numeric(t.values$statistic),  ## t value
                        as.numeric(t.values$parameter),  ## degrees of freedom
                        t.values$p.value))               ## p-value

  return(values)

}


#' @title t-test Combinations
#' @description Calculate all t-test Combinations
#' @details Calculate all t-test combinations within a list of values.
#'
#' @param data The `list` with the values to be compared. Each list should have
#'   a name otherwise names will be autogenerated.
#' @param alternative The type of t-test analysis; default: `"two.sided"`
#' @param paired `logical` indicating if the data is the result of a paired
#'   sample; default: `FALSE`
#' @param conf.level The confidence level; default: `0.99`
#' @param na.rm `logical` indicating if `NA` values are removed; default: `TRUE`
#'
#' @return A `data.frame` or `tibble` with the `t-value`, degrees of freedom
#'   (`df`), and `p-value`.
#'
#' @importFrom utils combn
#' @importFrom dplyr select
#' @importFrom tidyselect where
#' @importFrom tibble as_tibble is_tibble rownames_to_column
#'
#' @export
#'
#' @examples
#' \dontrun {
#'   values.ls <- list(a=1:3, b=1:5, c=1:10, d=1:20, e=letters[1:20])
#'   values.tb <- tibble::tibble(a=1:10, b=11:20, c=21:30, d=31:40, e=letters[1:10])
#'   combinations.t.test(values.ls)
#'   combinations.t.test(values.tb)
#' }
#'
#' @author Emilio Xavier Esposito \email{emilio@@exeResearch.com}
#'   ([https://github.com/emilioxavier](https://github.com/emilioxavier))
#'
combinations.t.test <- function(data,
                                alternative="two.sided",
                                paired=FALSE,
                                conf.level=0.99,
                                na.rm=TRUE) {

  ## is data.frame or tibble or list ----
  tb.tf <- is_tibble(data)
  df.tf <- is.data.frame(data)

  ## convert to list ----
  if ( tb.tf | df.tf ) {
    # data <- select(data, -where(is.character))
    data <- as.list(data)
  }

  ## remove character vectors ----
  data <- data[!sapply(X=data, FUN=is.character)]

  ## get group names ----
  names.groups <- names(data)
  ##_ if group names not provided, create ----
  if ( is.null(names.groups) == TRUE ) {
    num.groups <- length(data)
    max.group.nchar <- nchar(num.groups)
    group.idc <- seq_len(num.groups)
    num.groups.pretty <- formatC(group.idc, format="d", width=max.group.nchar, flag="0")
    names.groups <- paste0("group", num.groups.pretty)
    message("No group names provided, thus, group names created")
  }

  ## construct output data.frame ----
  num.groups <- length(names.groups)
  pairs.data <- combn(1:num.groups, 2)
  num.pairs <- ncol(pairs.data)
  num.df.results.rows <- num.groups * 3

  df.results <- as.data.frame(matrix(data=NA, nrow=num.df.results.rows, ncol=num.groups))
  df.row.names.t      <- paste0(names.groups, "_t")
  df.row.names.df     <- paste0(names.groups, "_df")
  df.row.names.pvalue <- paste0(names.groups, "_pvalue")

  ##_ row indices for row names ----
  t.rows.idc      <- seq(from=1, to=num.df.results.rows, by=3)
  df.rows.idc     <- seq(from=2, to=num.df.results.rows, by=3)
  pvalue.rows.idc <- seq(from=3, to=num.df.results.rows, by=3)

  ##_ update row and column names ----
  rownames(df.results)[t.rows.idc] <- df.row.names.t
  rownames(df.results)[df.rows.idc] <- df.row.names.df
  rownames(df.results)[pvalue.rows.idc] <- df.row.names.pvalue
  colnames(df.results) <- names.groups

  ## get the group pairs ----
  pairs.row1 <- pairs.data[1, ]
  pairs.row2 <- pairs.data[2, ]

  ## evaluate all group pairs ----
  for (curr.pair in seq_len(num.pairs)) {

    ##_ get the values ----
    x.values <- unlist(data[pairs.row1[curr.pair]])
    y.values <- unlist(data[pairs.row2[curr.pair]])

    ##_ determine rows and column for results ----
    results.row.last <- pairs.row1[curr.pair] * 3
    results.row.first <- results.row.last - 2
    results.rows <- results.row.first:results.row.last
    results.col <- pairs.row2[curr.pair]

    ##_ calculate the t-tests ----
    df.results[results.rows, results.col] <- values.t.test(x=x.values,
                                                           y=y.values,
                                                           alternative=alternative,
                                                           paired=paired,
                                                           conf.level=conf.level,
                                                           na.rm=na.rm)
  }

  ## remove column and rows of NAs ----
  df.results <- df.results[-c((num.df.results.rows-2):num.df.results.rows), -1]

  ## convert results to tibble if started as tibble ----
  if ( tb.tf ) {
    df.results <- rownames_to_column(df.results, var="t.test.param")
    df.results <- as_tibble(df.results)
  }

  ## return the results ----
  return(df.results)

}

